use std::{
    net::{TcpListener, TcpStream},
    io::{prelude::*, BufRead, BufReader}
};

pub struct Response {
    status_code: u8,
    status_message: String,
    headers: Vec<String>
}

const HTTP_VERSION: String = String::from("HTTP/1.1");

impl Response {
    pub fn new(status_code: u8) -> Response{
        return Response{status_code, status_message: String::from(""), headers: vec![]}
    }

    pub fn set_status_code(&mut self, status_code: u8) {
        self.status_code = status_code;
    }

    pub fn set_status_message(&mut self, status_message: String) {
        self.status_message = status_message;
    }

    pub fn add_header(&mut self, header_key: String, header_val: String) {
        self.headers.push(format!("{header_key}: {header_val}"));
    }

    pub fn get_response(&self) -> String {
        let mut res = String::from("");
        res.push_str(format!("{HTTP_VERSION} {self\.status_code} {status_message}").as_str());


        return res;
    }
}
pub fn handle_stream(mut stream: TcpStream) {
    let buf = BufReader::new(&stream);
    let _req: Vec<_> = buf
                      .lines()
                      .map(|res| res.unwrap())
                      .take_while(|line| !line.is_empty())
                      .collect();

    let response = "HTTP/1.1 200 OK\r\n\r\n";
    stream.write_all(response.as_bytes()).unwrap();
}

